[{"title":"RC4加密","path":"/2025/07/22/RC4加密/","content":"RC4加密简介RC4加密流程分析","tags":["逆向","算法"]},{"title":"IDA使用技巧","path":"/2025/07/22/IDA使用技巧/","content":"本文记录了在IDA使用时遇到的使用技巧 IDA 常见窗口函数列表窗口（Functions）列举所有已经被IDA识别的函数 IDA-View窗口汇编代码窗口，空格键切换图形模式和文本模式，TAB和F5键切换到伪代码窗口 Pseudocode窗口伪代码窗口，在伪代码位置按下TAB键可以切换到对应的汇编窗口 字符串窗口列举程序代码所有引用到的字符串常量 Shift + F12打开字符串窗口 Ctrl +F可以弹出底部搜索小窗口 F5召唤伪代码ida最基础的操作之一 味大无许多盐 G进行位置导航在IDA view界面进行使用G位置导航 R转换字符串在看伪代码时如果遇到长数字可以用R快捷键来转换成字符串 N给函数重命名A创建字符串，U解散字符串","tags":["IDA"]},{"title":"TEA加密","path":"/2025/07/18/TEa加密/","content":"tea算法是逆向中经常遇到的一种算法 算法特征tea算法的主要特征表现在sum和delta变量，以及3行核心加密中出现的右移4左移5，两行各有3个小括号互相异或 delta的值一般为0x9E3779B9(-0x61C88647)，但题目中往往会改变它的值 算法加密void tea_enc(uint32_t* v, uint32_t* k) uint32_t v0 = v[0], v1 = v[1]; // v0、v1分别是明文的左、右半部分 uint32_t sum = 0; // sum用作加密过程中的一个累加变量 uint32_t delta = 0xd33b470; //作为sum每次累加的变化值，题目中往往会修改此值 for (int i = 0; i 32; i++) // tea加密进行32轮 //以下3行是核心加密过程，题目中往往会对部分细节做出修改（但由于异或的对称性质，根本不需要记，写解密函数时照抄就行了） sum += delta; v0 += ((v1 4) + k[0]) ^ (v1 + sum) ^ ((v1 5) + k[1]); v1 += ((v0 4) + k[2]) ^ (v0 + sum) ^ ((v0 5) + k[3]); // v0和v1只是加密的临时变量，因此加密后的内容要还给v数组 v[0] = v0; v[1] = v1;————————————————版权声明：本文为CSDN博主「晴友读钟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/liKeQing1027520/article/details/141287289 算法解密脚本void tea_dec(uint32_t* v, uint32_t* k) uint32_t v0 = v[0], v1 = v[1]; // v0、v1分别是密文的左、右半部分 uint32_t delta = 0xd33b470; //作为sum每次累加的变化值，题目中往往会修改此值 uint32_t sum = 32 * delta; //此处需要分析32轮加密结束后sum的值与delta的变化, 以此处加密为例子，32轮每次sum+=delta，因此最后sum=32*delta for (int i = 0; i 32; i++) // tea加密进行32轮 //根据加密时的顺序颠倒下面3行的顺序，将加法改为减法（异或部分都是整体，不用管），就是逆向解密过程 v1 -= ((v0 4) + k[2]) ^ (v0 + sum) ^ ((v0 5) + k[3]); v0 -= ((v1 4) + k[0]) ^ (v1 + sum) ^ ((v1 5) + k[1]); sum -= delta; // 因此解密后的内容要还给v数组 v[0] = v0; v[1] = v1; 重点抓准——无论明文是什么形式、有多长，解密时一定是每次传入两个uint32_t（32位无符号整数）","tags":["逆向","算法"]},{"title":"初探逆向","path":"/2025/07/17/初探逆向/","content":"IDA动态调试01 动态调试概述IDA作为一款强大的逆向集成工具，对于动态调试也有比较好的支持。利用IDA自带的动态调试功能可以完成大部分动态调试任务。 动态调试是一种观察程序运行时状态的一种手段。 逆向工程中的动态调试的目的主要有： 1 验证静态分析结果 2 观察程序运行时数据 IDA调试器支持的特性： 1 软件断点硬件断点条件断点脚本断点 2 步入步过步出函数执行到光标位置 3 汇编级伪代码级源码级 调试代码支持 4 寄存器内存 读写 5 启动进程调试附加调试 02 Linux 远程动态调试ELF文件无法在win 上直接运行 IDA 远程调试需要一个远程调试服务端 实际调试指令的执行由调试服务端完成，IDA充当调试前端 IDA与该服务端通过tcp通信发送调试指令 调试机与被调试机之间需要保证网络畅通，一般是在同一个内网 03 动态调试技巧1 Ctrl + N 设置代码执行位置（可以用来跳过不想执行的代码） 2 Lazy IDA插件批量修改内存数据【Paste data】 3 附加调试（附加到一个正在运行的进程调试，一般成功后会断在一个固定的库函数里） ​\t1 一般用来调试动态库 ​\t2 绕过一些反调试","tags":["逆向","入门"],"categories":["逆向"]},{"title":"逆向题目题解","path":"/2025/07/14/逆向题目题解/","content":"记录了我目前做过的逆向题目和题解，以做题平台和比赛为分类依据 BUUCTF第八题 “helloword”既然是第一道题，那么写一个最简单的应该是很合理的 下载题目文件后，发现是一个.apk文件，把它拖入jadx，找到mainactivity,点开就是明晃晃的flag了 小结：题目确定没有拼错？？？ 第十题 “SimpleRev”下载文件后，拖入查壳软件中 没有壳，直接一套流程，就找到了伪代码 tcall __noreturn main(int argc, const char **argv, const char **envp) int v3; // eax char v4; // [rsp+Fh] [rbp-1h] while ( 1 ) while ( 1 ) printf(Welcome to CTF game! Please input d/D to start or input q/Q to quit this program: ); v4 = getchar(); if ( v4 != 100 v4 != 68 ) break; Decry();//关键函数，生成flag算法和比较算法 if ( v4 == 113 || v4 == 81 ) Exit(Welcome to CTF game! Please input d/D to start or input q/Q to quit this program: , argv); puts(Input fault format!); v3 = getchar(); putchar(v3); 打开Decry()函数 unsigned __int64 Decry() char v1; // [rsp+Fh] [rbp-51h] int v2; // [rsp+10h] [rbp-50h] int v3; // [rsp+14h] [rbp-4Ch] int i; // [rsp+18h] [rbp-48h] int v5; // [rsp+1Ch] [rbp-44h] char src[8]; // [rsp+20h] [rbp-40h] BYREF __int64 v7; // [rsp+28h] [rbp-38h] int v8; // [rsp+30h] [rbp-30h] __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF int v10; // [rsp+50h] [rbp-10h] unsigned __int64 v11; // [rsp+58h] [rbp-8h] v11 = __readfsqword(0x28u); *(_QWORD *)src = 0x534C43444ELL;//LL 是编程语言（如 C、C++ 等）中用于表示该数字为 long long 类型的后缀，并非数字本身的一部分，在转换成字符串时可以忽略，注意：数据在内存中是小端顺序，高位在高地址处，低位在低地址处，故实际的字符顺序应为0x4e44434c53经过16字符转换为ASCII码转换后字符为NDCLS v7 = 0LL; v8 = 0; v9[0] = 0x776F646168LL;//同理转换 v9[1] = 0LL; v10 = 0; text = join(key3, (const char *)v9); strcpy(key, key1); strcat(key, src); v2 = 0; v3 = 0; getchar(); v5 = strlen(key); for ( i = 0; i v5; ++i ) if ( key[v3 % v5] 64 key[v3 % v5] = 90 ) key[i] = key[v3 % v5] + 32; ++v3; printf(Please input your flag:); while ( 1 ) v1 = getchar(); if ( v1 == 10 ) break; if ( v1 == 32 ) ++v2; else if ( v1 = 96 || v1 122 ) if ( v1 64 v1 = 90 ) str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97; ++v3; else str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97; ++v3; if ( !(v3 % v5) ) putchar(32); ++v2; if ( !strcmp(text, str2) ) puts(Congratulation! ); else puts(Try again! ); return __readfsqword(0x28u) ^ v11; 通过观察和拼接可以得到key adsfkndcls\ttext killshadow 下面是大佬的解密程序 #includestdio.h int main()\tchar key[] = adsfkndcls;\tchar text[] = killshadow;\tint i;\tint v3=10;//长度 for (int i = 0; i 10; i++) for (int j = 0; j 128; j++) if (j A || j z || j Z j a) continue; if ((j - 39 - key[v3 % 10] + 97) % 26 + 97 == text[i]) printf(%c,j); v3++; break; ————————————————版权声明：本文为CSDN博主「Wαff1ε」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Waffle666/article/details/110250158 DUCTF也是第一次打国外的CTF比赛了，感觉自己又进化了（bush） Rocky下载好附件包，发现是二进制文件，用IDA打开文件 F5后得到伪代码 题目逻辑这个题目的逻辑还是很简单的 输入字符串—进行md5加密—将加密后的s2与已知数组s进行对比，一样就输出flag 解题思路s1数组是小端排序，想要获取数据有些麻烦 所以我们用IDA远端动态调试来获取数据 将获得数据进行md5解密后就得到了我们想要输入的数据： emergencycall911 MD5 在線免費解密 MD5、SHA1、MySQL、NTLM、SHA256、SHA512、Wordpress、Bcrypt 的雜湊 （感谢冬瓜大佬提供） 重启调试，我们就得到了flag Skippy这个题目writeup和我的解法不一样，我的解法是纯静态分析 个人解法在下载文件并用IDA打开后，用F5查看伪代码 伪代码 int __fastcall main(int argc, const char **argv, const char **envp) _QWORD v4[2]; // [rsp+20h] [rbp-40h] BYREF char n64_1; // [rsp+30h] [rbp-30h] _QWORD v6[2]; // [rsp+40h] [rbp-20h] BYREF char n64; // [rsp+50h] [rbp-10h] _main(); v6[0] = 0xE8BEF2E0E0D2D6E6uLL; v6[1] = 0xBED0E6EAC4BECAD0uLL; n64 = 64; sandwich(v6); v4[0] = 0xDEDEE4C2CEDCC2D6uLL; v4[1] = 0xDEDEDEDEDEDEDEDEuLL; n64_1 = 64; sandwich(v4); decrypt_bytestring(v6, v4); return 0; 从主函数我们可以看出来，现在有两个参数数组v6和v4在经过sandwich函数的改变后，传入decrypt_bytestring函数做参数 sandwich函数 __int64 __fastcall sandwich(__int64 a1) stone(a1); decryptor(a1); return stone(a1); 经过检查后发现sandwich函数中stone函数没有对传入a1进行改变，只有decryptor函数改变 decryptor函数 int __fastcall decryptor(__int64 a1) Stream *Stream; // rax Stream *Stream_1; // rax int result; // eax unsigned __int64 i; // [rsp+28h] [rbp-8h] Stream = __acrt_iob_func(2u); fwrite(Uh oh... Skippy sees a null zone in the way... , 1u, 0x2Fu, Stream); Stream_1 = __acrt_iob_func(2u); fflush(Stream_1); result = _mingw_printf(%d , MEMORY[0]);//不必理会 //真正改变传入的参数数组的算法 for ( i = 0; i = 0xF; ++i ) result = a1 + i; *(_BYTE *)(a1 + i) = 1; return result; 我们发现其实就是将每个字节右移一位 将数组 v6和v4带入，可以得到处理过后的数组 v6[0] = 0x745F797070696B73 // 对应字符串 skippy_tv6[1] = 0x5F687375625F6568 // 对应字符串 he_bush_v4[0] = 0x6F6F7261676E616B // 对应ASCII字符串 kangaroo（小端：6B=k,61=a,6E=n,67=g,61=a,72=r,6F=o,6F=o）v4[1] = 0x6F6F6F6F6F6F6F6F // 对应ASCII字符串 oooooooo decrypt_bytestring函数 int __fastcall decrypt_bytestring(__int64 a1, __int64 a2) void *v2; // rsp _BYTE Buffer_1[200]; // [rsp+20h] [rbp-60h] BYREF char *Buffer; // [rsp+E8h] [rbp+68h] __int64 n96; // [rsp+F0h] [rbp+70h] size_t Size; // [rsp+F8h] [rbp+78h] Size = 96; n96 = 96; v2 = alloca(112); Buffer = Buffer_1; memcpy(Buffer_1, precomputed, 0x60u);//获得加密密文 AES_init_ctx_iv(Buffer_1, a1, a2);//密钥拓展 AES_CBC_decrypt_buffer(Buffer_1, Buffer, Size); Buffer[Size] = 0; stone(Buffer); return puts(Buffer); 然后就是一个有密钥拓展的AES-CBC算法 from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadfrom Crypto.Random import get_random_bytes def decrypt(encrypted_data,key): # Base64解码 raw_data = encrypted_data # 提取IV(前16字节)和密文 iv = raw_data[:AES.block_size] # ciphertext = raw_data[AES.block_size:] ciphertext = raw_data[AES.block_size:] # 创建AES-CBC解密器 cipher = AES.new(key, AES.MODE_CBC, iv) # 解密并去除填充 decrypted_data = unpad(cipher.decrypt(ciphertext), AES.block_size) return decrypted_data.decode(utf-8)# 或者使用固定密钥(16字节)iv = bkangarooooooooookey = bskippy_the_bush_ ciphertext = bytes.fromhex(iv.hex()+AE27241B7FFD2C8B3265F22AD1B063F0915B6B95DCC0EEC14DE2C563F7715594007D2BC75E5D614E5E51190F4AD1FD21C5C4B1AB89A4A725C5B8ED3CB37630727B2D2AB722DC9333264725C6B5DDB00DD3C3DA6313F1E2F4DF5180D5F3831843)decrypted = decrypt(ciphertext,key)print(解密后的数据:, decrypted)print(len(decrypted)) 运行一下结果就出来了 官方解法查看伪代码，发现stone函数和decryptor函数存在无效指针读取操作 找到对应的汇编，把对应结果给nop掉 然后让程序运行一下就得到了flag 第一次修改汇编，发现程序并没有按照自己的修改跑起来，原本以为要用动态调试，结果报了一堆奇奇怪怪的错误，查资料后了解到是要将修改后的数据保存在输入的文件中 选择那个Apply patches to input file 然后就可以正常运行了","tags":["逆向","题解"],"categories":["题解"]},{"title":"安卓逆向入门笔记","path":"/2025/07/11/安卓逆向入门笔记/","content":"cmd与环境变量1. cmd的打开方式开始 - 右键 -运行 - cmd 指定目录快捷打开cmd； 路径栏输入cmd 2. cmd基本操作dir： ​\t显示当前路径下的所有文件 cls： ​\t清屏 cdd： ​\t用于切换不同盘之间的文件 cd： ​\tchange dirction 改变当前位置 cd . . ​\t回到上级目录 cmd中运行文件 ，上下键选择之前输入过的命令，tab补全，右键复制粘贴 3.相对路径和绝对路径路径名从C盘，D盘开始到你想要去的位置是绝对路径，而从当前位置到你想去的位置是相对路径 4. 环境变量系统变量用户变量 环境变量的作用 ： 通过加入环境变量可以让你在不同的位置来访问文件","tags":["安卓逆向"],"categories":["逆向"]},{"title":"初识JAVA","path":"/2025/07/10/初识JAVA/","content":"JAVA语言特点1.面向对象，强类型 完全面向对象： Java是纯粹的面向对象语言，所有代码都必须封装成类使用，即使是简单的”Hello World”程序也需要定义类和main方法作为程序入口。 强类型特性： 区别于JavaScript等弱类型语言，Java要求变量必须明确定义数据类型。 2. 垃圾自动回收机制 回收机制： Java的GC不是立即回收不再使用的内存，而是由JVM决定回收时机，但保证最终会回收。 对比CC++： 在CC++中，堆内存需要程序员手动释放，否则会导致内存泄漏，最终可能使程序崩溃。 作用域限制： Java变量一旦超出作用域，程序就无法再访问该变量，为GC回收创造条件。 3. 解释型 编译过程： Java需要先将源代码(.java)编译为字节码(.class)，这点区别于JavaScriptPHP等纯解释型语言。 语言分类对比： 解释型语言：JavaScript、Python、PHP（直接解释执行） 编译型语言：CC++（直接编译为机器码如.exe） Java特点：介于两者之间，先编译为字节码再由JVM解释执行 4. 跨平台 核心机制： 通过Java虚拟机(JVM)实现”一次编译，到处运行”，同一份.class文件可在WindowsLinuxMac等平台运行。 实现原理： 不同平台安装对应版本的JVM JVM屏蔽底层平台差异 字节码由各平台JVM解释执行 对比CC++：CC++程序需要针对不同平台重新编译，可能还需修改代码，而Java只需编译一次。 编译 javac Demo. java 运行 java Demo 第一个Java程序1. 第一个程序tips:利用的是notepad++软件 public class Hello public static void main(String[] args) System.out.println(Hello China!); 2. Java程序的注意事项Java源文件以.java为扩展名 Java语言区分大小写 public class Hello 表示 Hello 是公有类 一个文件只能有一个公有类，并且类名要与文件名一致，其他类数量不限 { } 代码的开始和结束 main 主方法，是程序的入口，必须有，不能改 打印输出字符串 语句结束用 ; 所有的符号都是英文状态下的 源文件使用UTF-8编码 Java语言基础组成（语言共性）1. 注释1. 单行注释格式：注释文字 2. 多行注释格式：* 注释文字 * 3. 被注释的文字不会被JVM解释执行多行注释不能嵌套 tips ：由于编码问题导致编译失败，代码块里含有中文的情况下，中文默认的是GDK编码，而我们一般默认的是UTF-8编码。会报错。解决：设置环境变量 JAVA_TOOL_OPTIONS -Dfile.encodingUTF-8 2. 变量3. 常量4. 关键字\t保留字5. 标识符6. 运算符7. 语句8. 函数9. 数组","tags":["JAVA","基础"],"categories":["基础"]}]